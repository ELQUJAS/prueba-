Centrar el Mapa en la Capa 'union' al Cargar
¡Claro! Para que tu mapa se centre automáticamente en la extensión completa de la capa union_2 al cargarse, necesitamos hacer un pequeño ajuste en la inicialización del mapa.

Actualmente, el mapa se inicializa con coordenadas y un nivel de zoom fijo:

JavaScript

var map = L.map('map', {
    zoomControl:true, maxZoom:28, minZoom:1
}).fitBounds([[-44.07722688524058,-77.37190246581997],[-34.11351005213069,-57.94807434081983]]);
En lugar de esas coordenadas fijas, utilizaremos el método fitBounds de Leaflet con los límites de tu capa union_2. Sin embargo, hay un detalle importante: la capa union_2 se carga de forma asíncrona (es decir, en segundo plano). No podemos obtener sus límites inmediatamente después de la línea var layer_union_2 = new L.geoJson(...) porque los datos aún no estarán completamente disponibles.

La solución es usar un evento de Leaflet que se dispara cuando la capa GeoJSON ha terminado de cargar sus datos y ha añadido sus elementos al mapa. El evento ideal para esto es el evento 'data:loaded' del plugin leaflet-search, o simplemente asegurarnos de que la capa esté añadida y luego llamar a fitBounds sobre el bounds_group.

La forma más sencilla y robusta, dado tu código, es mover la llamada a setBounds() para que se ejecute después de que layer_union_2 se haya añadido al mapa y sus características hayan sido procesadas. Ya tienes un bounds_group al que se añade layer_union_2, lo que es perfecto.

Script Actualizado
Aquí está el script con la modificación para centrar el mapa:

HTML

<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="initial-scale=1,user-scalable=no,maximum-scale=1,width=device-width">
        <meta name="mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <link rel="stylesheet" href="css/leaflet.css">
        <link rel="stylesheet" href="css/qgis2web.css"><link rel="stylesheet" href="css/fontawesome-all.min.css">
        <link rel="stylesheet" href="css/leaflet-search.css">
        <style>
        html, body, #map {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
        }
        </style>
        <title></title>
    </head>
    <body>
        <div id="map">
        </div>
        <script src="js/qgis2web_expressions.js"></script>
        <script src="js/leaflet.js"></script>
        <script src="js/leaflet.rotatedMarker.js"></script>
        <script src="js/leaflet.pattern.js"></script>
        <script src="js/leaflet-hash.js"></script>
        <script src="js/Autolinker.min.js"></script>
        <script src="js/rbush.min.js"></script>
        <script src="js/labelgun.min.js"></script>
        <script src="js/labels.js"></script>
        <script src="js/leaflet-search.js"></script>
        <script src="data/union_2.js"></script>
        <script>
        var highlightLayer;
        function highlightFeature(e) {
            highlightLayer = e.target;

            if (e.target.feature.geometry.type === 'LineString') {
              highlightLayer.setStyle({
                color: '#ffff00',
              });
            } else {
              highlightLayer.setStyle({
                fillColor: '#ffff00',
                fillOpacity: 1
              });
            }
        }
        var map = L.map('map', {
            zoomControl:true, maxZoom:28, minZoom:1
        }); // Eliminamos el .fitBounds inicial aquí.

        var hash = new L.Hash(map);
        map.attributionControl.setPrefix('<a href="https://github.com/tomchadwin/qgis2web" target="_blank">qgis2web</a> &middot; <a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a> &middot; <a href="https://qgis.org">QGIS</a>');
        var autolinker = new Autolinker({truncate: {length: 30, location: 'smart'}});
        function removeEmptyRowsFromPopupContent(content, feature) {
           var tempDiv = document.createElement('div');
           tempDiv.innerHTML = content;
           var rows = tempDiv.querySelectorAll('tr');
           for (var i = 0; i < rows.length; i++) {
               var td = rows [i].querySelector('td.visible-with-data');
               var key = td ? td.id : '';
               if (td && td.classList.contains('visible-with-data') && feature.properties [key] == null) {
                   rows [i].parentNode.removeChild(rows [i]);
               }
           }
           return tempDiv.innerHTML;
        }
        document.querySelector(".leaflet-popup-pane").addEventListener("load", function(event) {
          var tagName = event.target.tagName,
            popup = map._popup;
          // Also check if flag is already set.
          if (tagName === "IMG" && popup && !popup._updated) {
            popup._updated = true; // Set flag to prevent looping.
            popup.update();
          }
        }, true);
        var bounds_group = new L.featureGroup([]); // Este FeatureGroup es clave
        
        // La función setBounds ahora sí realizará la acción de centrar
        function setBounds() {
            if (bounds_group.getLayers().length > 0) {
                map.fitBounds(bounds_group.getBounds());
            }
        }

        map.createPane('pane_EsriSatellite_0');
        map.getPane('pane_EsriSatellite_0').style.zIndex = 400;
        var layer_EsriSatellite_0 = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            pane: 'pane_EsriSatellite_0',
            opacity: 1.0,
            attribution: '',
            minZoom: 1,
            maxZoom: 28,
            minNativeZoom: 0,
            maxNativeZoom: 17
        });
        map.addLayer(layer_EsriSatellite_0);

        map.createPane('pane_OpenStreetMap_1');
        map.getPane('pane_OpenStreetMap_1').style.zIndex = 401;
        var layer_OpenStreetMap_1 = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            pane: 'pane_OpenStreetMap_1',
            opacity: 1.0,
            attribution: '',
            minZoom: 1,
            maxZoom: 28,
            minNativeZoom: 0,
            maxNativeZoom: 19
        });

        function pop_union_2(feature, layer) {
            layer.on({
                mouseout: function(e) {
                    for (i in e.target._eventParents) {
                        e.target._eventParents [i].resetStyle(e.target);
                    }
                },
                mouseover: highlightFeature,
            });
            var popupContent = '<table>\
                    <tr>\
                        <th scope="row">Categoría:</th>\
                        <td>' + (feature.properties ['Name'] !== null ? autolinker.link(feature.properties ['Name'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <th scope="row">Descripción:</th>\
                        <td>' + (feature.properties ['descriptio'] !== null ? autolinker.link(feature.properties ['descriptio'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <th scope="row">Academicos:</th>\
                        <td>' + (feature.properties ['Academicos'] !== null ? autolinker.link(feature.properties ['Academicos'].toLocaleString()) : '') + '</td>\
                    </tr>\
                </table>';
            layer.bindPopup(popupContent, {maxHeight: 400});
            var popup = layer.getPopup();
            var content = popup.getContent();
            var updatedContent = removeEmptyRowsFromPopupContent(content, feature);
            popup.setContent(updatedContent);
        }

        function getColor(nombre) {
            const nameLower = String(nombre).toLowerCase();

            if (nameLower.includes('universidad')) {
                return '#E41A1C'; // Rojo vivo
            } else if (nameLower.includes('escuela')) {
                return '#377EB8'; // Azul brillante
            } else if (nameLower.includes('colegio')) {
                return '#4DAF4A'; // Verde vibrante
            } else if (nameLower.includes('instituto')) {
                return '#984EA3'; // Morado
            } else if (nameLower.includes('centro cultural')) {
                return '#FF7F00'; // Naranja
            } else if (nameLower.includes('biblioteca')) {
                return '#FFFF33'; // Amarillo
            } else {
                return '#A65628'; // Marrón, para cualquier otra categoría no especificada
            }
        }

        function style_union_2_0(feature) {
            return {
                pane: 'pane_union_2',
                radius: 4.0,
                opacity: 1,
                color: 'rgba(35,35,35,1.0)',
                dashArray: '',
                lineCap: 'butt',
                lineJoin: 'miter',
                weight: 1,
                fill: true,
                fillOpacity: 1,
                fillColor: getColor(feature.properties['Name']),
                interactive: true,
            }
        }

        map.createPane('pane_union_2');
        map.getPane('pane_union_2').style.zIndex = 402;
        map.getPane('pane_union_2').style['mix-blend-mode'] = 'normal';
        var layer_union_2 = new L.geoJson(json_union_2, {
            attribution: '',
            interactive: true,
            dataVar: 'json_union_2',
            layerName: 'layer_union_2',
            pane: 'pane_union_2',
            onEachFeature: pop_union_2,
            pointToLayer: function (feature, latlng) {
                var context = {
                    feature: feature,
                    variables: {}
                };
                return L.circleMarker(latlng, style_union_2_0(feature));
            },
        });
        bounds_group.addLayer(layer_union_2);
        map.addLayer(layer_union_2);

        var baseMaps = {
            "Esri Satellite": layer_EsriSatellite_0,
            "OpenStreetMap": layer_OpenStreetMap_1
        };

        var overlayMaps = {
            '<img src="legend/union_2.png" /> union': layer_union_2
        };

        L.control.layers(baseMaps, overlayMaps, {
            collapsed: false
        }).addTo(map);

        // --- INICIO DE LA MODIFICACIÓN PARA CENTRAR EL MAPA ---
        // Llama a setBounds después de que la capa GeoJSON haya sido añadida al mapa
        // y por lo tanto sus límites estén disponibles en bounds_group.
        map.on('overlayadd', function(eventLayer) {
            if (eventLayer.layer === layer_union_2) {
                setBounds();
            }
        });

        // Asegurarse de que se centre si union_2 es la capa activa por defecto
        // (lo cual debería ser, ya que la añades con map.addLayer(layer_union_2);)
        setBounds(); // Llama setBounds una vez al inicio también
        // --- FIN DE LA MODIFICACIÓN ---

        map.addControl(new L.Control.Search({
            layer: layer_union_2,
            initial: false,
            hideMarkerOnCollapse: true,
            propertyName: 'Name',
            zoom: 16
        }));

        document.getElementsByClassName('search-button')[0].className +=
            ' fa fa-binoculars';
        </script>
    </body>
</html>
